{
  "hash": "f04af90878c2d1e7df99b6808b01dd9e",
  "result": {
    "markdown": "---\ntitle: \"Une calculette en HAD\"\ndescription: \"Un outil simple et rapide pour faire correspondre des GHPC à leur GHT et tarifs\"\ndate: \"2023-03-01\"\ndate-modified: last-modified\ncategories: [HAD, outils, serverless, R]\nimage: \"calculator.jpg\"\n---\n\n\nLors de discussion avec une collègue, nous avons eu besoin d'avoir rapidement de nombreuses combinaisons de MPP MPA IK et d'observer leurs GHT, mais aussi l'inverse : à partir d'un GHT observer les combinaisons possibles de GHPC. Puisque ma collègue appelait cet outil une \"calculette\", j'ai gardé le nom !\n\nLes données sont entièrement en libre accès sur le site de l'ATIH :\n\n- [mapping ghpc en ght](https://www.atih.sante.fr/guide-methodologique-had-2022)\n- [nomenclature (guide méthodo)](https://www.atih.sante.fr/guide-methodologique-had-2022)\n- [tarifs 2022](https://www.atih.sante.fr/tarifs-mco-et-had)\n\nÉtonnamment nous n'avions pas, à ma connaissance, d'outil interne qui fasse ce simple croisement de données. C'est l'affaire d'un simple Excel bien entendu mais tout entrainement qui amène à ne pas se servir d'Excel comme outil de publication ou visualisation de données me semble justifié (gif anti excel?)\n\nJe procède en deux temps : d'abord je prepare une table de référence puis je la met en page avec `{flexdashboard}` et `{reactable}`\n\n## Préparation des données\n\nOn commence par charger les données :\n\n```r\nlibrary(dplyr, warn.conflicts = FALSE)\n\ndta_raw <- readxl::read_excel(\"data-raw/ghpc_2022.xlsx\", sheet = 3)\ndta_libs_mps <- readxl::read_excel(\"data-raw/lib_mps.xlsx\")\ndta_tarifs <- readxl::read_excel(\"data-raw/tarifs2022.xlsx\")\n```\n\n> NB: Pour les libellés de MP j'avais déjà une table dans un package interne ATIH mais elle est construite simplement à partir du guide méthodo. Pour cet exemple j'ai fait une feuille excel avec mp et libellé issus du guide.\n\nIl me faut aussi une table avec les bornes de pondération de GHT pour faire correspondre les pondération de GHPC dans un GHT :\n\n```r\ndta_ght <-\n    data.frame(\n        lower_pond =\n            seq(\n                from = .57,\n                to = 6.57,\n                by = .2\n            ),\n        upper_pond = \n            c(\n                seq(\n                    from = .77,\n                    to = 6.57,\n                    by = .2\n                ),\n                99\n            ),\n        ght = 1:31\n    )\n\n```\n\nJe prépare mes données en renommant les colonnes dans un format plus facile à manier en code : \n\n```r\ndta_select <-\n    dta_raw |> \n    select(\n        ghpc = GHPC,\n        inat = `Association inattendue`,\n        mpp = MPP,\n        mpa = MPA,\n        ik = IK, \n        t1 = `IPT T1`,\n        t2 = `IPT T2`,\n        t3 = `IPT T3`,\n        t4 = `IPT T4`,\n    )\n```\n\nJe pivote mes données pour un format long car j'anticipe qu'il sera plus facile de les manier comme ça pour filtrer sur les valeurs de tranches de durée de séquence :\n\n```r\ndta_pivot <-\n    dta_select |> \n    tidyr::pivot_longer(\n        cols = c(\n            t1,\n            t2,\n            t3,\n            t4\n        ),\n        names_to = \"tranche\",\n        values_to = \"pond\"\n    ) |> \n    mutate(\n        tranche = factor(\n            tranche,\n            levels = c(\"t1\", \"t2\", \"t3\", \"t4\"),\n            labels = c(\"J1-J4\", \"J5-J9\", \"J10-J30\", \"J31-sortie\")\n        )\n    )\n```\n\nJe souhaite aussi avoir une homogénéité dans les valeurs d'IK alors je vais transformer l'ik pour extraire les quelques valeurs double (XX-XX) puis à nouveau pivoter en long\n\n```r\ndta_mutateik <-\n    dta_pivot |> \n    mutate(\n        ik1 = stringr::str_extract(\n            string = ik, \n            pattern = \"^\\\\d+\"\n        ),\n        ik2 = stringr::str_extract(\n            string = ik, \n            pattern = \"\\\\d+$\"\n        )\n    ) |> \n    select(-ik)\n\ndta_pivotik <-\n    dta_mutateik |> \n    tidyr::pivot_longer(\n        cols = c(ik1, ik2),\n        names_to = \"ik_val\",\n        values_to = \"ik\"\n    ) |> \n    select(-ik_val) |> \n    distinct()\n```\n\nPuis avec de simples jointures je crée une table  unique. \n\n```r\ndta_join <-\n    dta_pivotik |> \n    left_join(\n        y = dta_ght,\n        by = join_by(pond >= lower_pond, pond < upper_pond)\n    ) |> \n    left_join(\n        y = dta_tarifs,\n        by = \"ght\"\n    )\n```\n\nJ'ajoute les libellés pour une lecture plus facile\n\n```r\ndta_libs <- \n    dta_join |> \n    left_join(\n        y = dta_libs_mps,\n        by = c(\"mpp\" = \"code\")\n    ) |> \n    rename(libmpp = libmp) |> \n    left_join(\n        y = dta_libs_mps,\n        by = c(\"mpa\" = \"code\")\n    ) |> \n    rename(libmpa = libmp) |> \n    mutate(\n        libmpp = paste0(mpp, \" : \", libmpp),\n        libmpa = paste0(mpa, \" : \", libmpa),\n        ik = as.integer(ik)\n    )\n```\n\nEt ma table est prête à être utilisée. Je peux la sauvegarder dans un fichier Excel, ou mieux un fichier .rds qui prend moins de place et charge plus vite avec R :\n\n```r\nbdd <-\n    dta_libs |> \n    select(\n        mpp, libmpp, mpa, libmpa, ik, tranche, ghpc, ght, tarif_pub, tarif_pri, inat\n    ) |> \n    arrange(\n        mpp,\n        mpa,\n        ik,\n        tranche\n    )\n\nsaveRDS(bdd, \"data/bdd.rds\")\n```\n\nMa table finale ressemble à ça : \n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\n  mpp                       libmpp mpa  libmpa ik tranche ghpc ght tarif_pub\n1  01 01 : Assistance respiratoire  00 00 : NA 10   J1-J4 1902  20    408.73\n2  01 01 : Assistance respiratoire  00 00 : NA 10   J5-J9 1902  14    299.10\n3  01 01 : Assistance respiratoire  00 00 : NA 10 J10-J30 1902  13    280.81\n  tarif_pri inat\n1    406.87  non\n2    297.64  non\n3    279.43  non\n```\n:::\n:::\n\n\n## Visualisation\n\nPour mettre ce tableau en page je vais utiliser `{flexdashboard}`, avec une disposition `sidebar` pour pouvoir mettre des elements à côté de la table. \n\nJe crée un fichier .Rmd avec l'entête suivant :\n\n```yaml\n---\ntitle: \"Calculette GHT HAD\"\noutput:\n    flexdashboard::flex_dashboard:\n        vertical_layout: fill\n        theme:\n            version: 4\n            bootswatch: cyborg\n---\n```\n\nJe charge les librairies dont je vais avoir besoin :\n\n``` {{r}}\n#| include: false\nlibrary(htmltools)\nlibrary(shiny)\nlibrary(reactable)\nlibrary(reactablefmtr)\nlibrary(crosstalk)\nlibrary(hadcalculette)\nlibrary(flexdashboard)\n```\n\nEt je charge les données, et je les passe à `{crosstalk}` dans un objet partagé:\n\n``` {{r}}\nbdd <- readRDS(\"bdd.rds\")\nshared_bdd <- SharedData$new(bdd)\n```\n\nEnsuite, je voudrais pouvoir filtrer sur mes éléments d'interet : mpp mpa ik ght et tranche\nJ'utilise {crosstalk} pour faire communiquer des inputs avec la table.  \n\nJe commence par créer la partie UI avec des filtres comme celui-ci :\n\n``` {{r}}\nfilter_select(\n    id = \"mpp\",\n    label = \"MPP\",\n    sharedData = shared_bdd,\n    group = ~libmpp\n)\n```\n\nEt de l'autre côté j'encapsule ma table dans un format réactif avec `{reactable}`>\n\nPuis une fois satisfait je connecte avec les données du tableau pour qu'il soit filtré quand je fais des choix. \nNB: Il y a aussi des filtres puissants dans {reactable} mais je suis plus à l'aise visuellement avec mes filtres à gauche en menu déroulant plutôt que les filtres texte libre de {reactable}\n\nLe code complet de cette portion est disponible [dans le dépôt](https://github.com/rsimonmd/calculettehad/blob/main/index.Rmd)\n\nEt voilà le travail! \nIl n'y a plus qu'à déployer sur github pages ou équivalent\n\nA bientôt,\n\nRaphaël",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}